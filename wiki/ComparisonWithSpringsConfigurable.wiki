#summary Compares Salve's @Dependency and Spring's @Configurable Annotation
#labels Featured

Spring 2.0 has introduced @Configurable annotation that overlaps somewhat with Salve functionality. Just like Salve, @Configurable allows injection of POJOs even if their lifecycle is outside the Spring container. Following is a comparison of the approaches Salve and @Configurable take:

  * @Configurable is Spring dependent, Salve is not. The @Configurable annotation will only work if the project is using Spring and it will only work for dependencies defined within the Spring container. Salve can lookup dependencies from anywhere, provided the proper locators are installed. For example, if the project is using both Spring and Guice, POJOs can contain dependencies defined in either or in both containers.

  * @Configurable is a class-level annotation, while @Dependency is field-level. Being a field-level annotation @Dependency allows more granular control of how the dependencies are looked up. @Configurable allows the same amount of control *if* the application context contains the bean definition for the POJO being injected, which can get cumbersome to maintain if there are a lot of POJOs.

  * @Configurable injects POJOs eagerly after construction. Dependencies must be declared transient in order not be serialized, @Configurable will intercept deserialization and reinject dependencies. By default, Salve removes field references, making memory footprint of the POJO smaller, at the price of more frequent lookups (Salve uses a cache which should make performance overhead unnoticeable). Salve does have an option which will keep the field reference and only inject it when it is null ( @Dependency(strategy=InjectionStrategy.INJECT_FIELD) ) which makes it comparable with how @Configurable works.